---
title: "Expert Choice"
author: "Jed Stephens"
date: '`r format(Sys.Date(), "%d %B %Y")`'
output: rmarkdown::github_document
---

<!-- README.md is generated from README.Rmd. Please edit README.Rmd to make changes. -->

```{r, echo = FALSE}
knitr::opts_chunk$set(collapse=TRUE, comment="##", fig.retina=2, fig.path = "README_figs/README-")
```

The purpose of this example is to present a practical worked example of how to design a conjoint and discrete choice experiment without blocking.
This tutorial accompanies the note: Designing conjoint scaling and discrete choice experiments for small sample expert surveys by Jed Stephens which may give some more theoretical insight.

# Step 0: Decide on what to test
The following table gives the attributes and thier associated levels for reserach involving antique silver experts. 
Although you do not need to create a table of this format in order to use the software it is beneficial to have an idea of what you wish to test and what would be suitable levels upon which to test it.
The process of choosing a design often involes interating over steps 0 to 4. 
Some designs are more difficult to create than others.

Here are some practical suggestions as to what makes a good design.
1. In general avoid attributes with only two levels. The design such as the one below suffers because it is difficult to convert from the fractional fractorial of this design into an effient choice experiment design. The lack of efficiency is not from the methods of converting, but inherit in the fact that achieving the minimal overlap when there is only two levels is diffciult.

| z | attribute name   (z) | z_l | level name   (z_l) | Description |
|:-:|:--------------------:|:---:|:----------------------------------------:|:------------------------------:|
| 1 | Makers Renown | 1 | little known | Bottom 50% of makers |
| 1 | Makers Renown | 2 | known to specialists | Middle 50% to 75% |
| 1 | Makers Renown | 3 | recognised | 75% to 90% |
| 1 | Makers Renown | 4 | famous | top 10% |
| 2 | Technical Perfection | 1 | below average | Bottom 50% of  craftsmanship |
| 2 | Technical Perfection | 2 | good | Middle 50% to 75% |
| 2 | Technical Perfection | 3 | meritorious | 75% to 90% |
| 2 | Technical Perfection | 4 | exceptional | top 10% |
| 3 | Category Rarity | 1 | common | bottom 25% of  category rarity |
| 3 | Category Rarity | 2 | uncommon | 25% to 50% |
| 3 | Category Rarity | 3 | rare | 50% to 75% |
| 3 | Category Rarity | 4 | very rare | top 25% |
| 4 | Size (of object) | 1 | small | under 150g |
| 4 | Size (of object) | 2 | medium | between 151g and 400g |
| 4 | Size (of object) | 3 | large | between 401g and 1000g |
| 4 | Size (of object) | 4 | extra large | larger than 1000g |
| 5 | Age (of object) | 1 | 21st or 20th Century | Years 1900 to present |
| 5 | Age (of object) | 2 | 19th Century | Years 1800 to 1899 |
| 5 | Age (of object) | 3 | 18th Century | Years 1700 to 1799 |
| 5 | Age (of object) | 4 | Before 18th Century | Before 1700 |
| 6 | Provenance | 1 | unavailable or available but unimportant |  |
| 6 | Provenance | 2 | available & important |  |

# Step 1: Construct the full factorial
First load the the `ExpertDesign` package into your R environemnent.
```{r}
library(ExpertChoice)
```

Create a list object which specifies the name of the variables as well as thier respective levels.  
**NB: The levels should be integer sequential and start from 1** 
As the proposed design above is a $4^4 2^1$ I have chosen to denote the object as `attr4521`:
```{r}
attri4521  = list(maker = c("1", "2", "3", "4"),
                  technical =c("1", "2", "3", "4"),
                  category_rarity = c("1", "2", "3", "4"),
                  size = c("1", "2", "3", "4"),
                  age = c("1", "2", "3", "4"),
                  provenance = c("1", "2"))
```

Calling the list object something like this is advantagous because you could have multiple competing designs still at this stage. 
For example `attri4531`:
```{r}
attri4531  = list(maker = c("1", "2", "3", "4"),
                  technical =c("1", "2", "3", "4"),
                  category_rarity = c("1", "2", "3", "4"),
                  size = c("1", "2", "3", "4"),
                  age = c("1", "2", "3", "4"),
                  provenance = c("1", "2", "3"))
```

Create the full factorial object. 
Using the design specification as a suffix remains a handy way of keeping track of the design.

```{r}
ff4521 <- full_factorial(attri4521)
```

The full factorial will contain many rows. 
The first five rows and the last five are given below:
```{r}
rbind(head(ff4521, 5), tail(ff4521, 5))
```

For every variable in the full factorial has the standaridised orthogonal contrast applied.
These constrasts are very useful when eveluating the efficacy of a design.
This is simply illustrative:
```{r}
contrasts(ff4521$maker)
```

# Step 2: Augment the full factorial

Once the full facotrial is constructed it is possible to augment it some additional information.
Many of these augmentations happen as attributes. 
This includes adding the B-matrix (for main effects) as described by Street et al...
The prefix `af` is used to refer to the augmented (full) factorial.
(You could of course name the object whatever you prefer.)

```{r}
aff4521 <- augment_levels(ff4521)
```

A console log will appear stating that the processes of applying the B-matrix has started.
If you do not get this message then the B-matrix cannot be added. 
(Please open a GitHub issue if this is the case. I am not aware of instances where this should happen.)
The B-matrix plays an important role in the choice efficiency of design.
Below are ten random rows drawn from the agumented full factorial. 
Notice the additional of the `levels` column.
```{r}
aff4521[sample(nrow(aff4521), 10), ]
```

# Step 3: Creating a fractional factorial design.
```{r load-packages, message=FALSE}
library(AlgDesign)
library(DoE.base)
#library(DoE.MIParray)
```

There are many ways to create a fractional factorial design. 
See Section ... of the associated note Designing conjoint scaling and discrete choice experiments for small sample expert surveys by Jed Stephens for a full discussion.
Practically speaking though two methods are designed to be flawlessly integreated into this package.
These are the construction of a fractional factorial design using an orthogonal array with either the `DoE.MIParray` or `DoE.base` packages or using D-optimal fractional factorial designs from the `AlgDesign` package.

## Ortogonal Arrays (`DoE.MIParray` or `DoE.base`)

### Determine feasiability

The function `oa_feasible()` from the `DoE.base` package (`DoE.base::oa_feasible()`) provides many methods for determining if a particular design can be construed with $N_D$ rows.
For the silver expert it was found that the following design was feasiable.
It is possible to specifiy higher resolution designs.
These are always advantageous. 
See Section ... of the associated note Designing conjoint scaling and discrete choice experiments for small sample expert surveys by Jed Stephens for a full discussion.

```{r}
# Design: DF: 17, 32 OA (Resolution II), 64 OA (Resolution III)
oa_feasible(32, c(4,4,4,4,4,2), strength = 2)
```

Using the `DoE.base` package it is possible to construct a 32 .

When consturcting a design using the `DoE.MIParray`... 
The function `mosek_MIParray()` was used to construct the example 64 run orthogonal array included with this package.

```{r}
# Not run because it requires time as well as some setting up if this is your first time.
# See DoE.MIParray for more detials.
# fractional_factorial_4521_64 <- mosek_MIParray(64, c(4,4,4,4,4,2), maxtime = 54000)
```

We can instead load this object from the package. 
It is called `silver_4521_64`.
The data is loaded into the enviroment and then the first ten rows are presented.
```{r}
silver_4521_64 <- ExpertChoice::silver_4521_64
head(silver_4521_64, 10)
```

## D-efficient
Not yet discussed or though it should be achieveable with mininal effort. 
If a reader wishes for this example to be completed before I have done so please open a GitHub issue and I shall happily oblige completing.


# Step 4: Searching the full factorial for the chosen fractional factorial design
The ability to use multiple different packages to construct the fractional factorial design is ensured by this step.
There can exist small differences between the different methods which require some fiddiling.

The results of the `mosek_MIParray` function are orthogonal arrays without colnames.
Hence in this instance the colnames need to be added. 
This design clearly needed to be made with the full factiorial in mind.
Hence the colnames from the `ff4521` object are appropriate.
**Note: the colnames from the aff4521 would include the levels column -- hence avoid these...**

```{r warning=FALSE}
colnames(silver_4521_64)<- colnames(ff4521)
fractional_f4521_64 <- search_design(ff4521, silver_4521_64)
```

The result is a fracitonal fractional design.
Importantly though the fractional factorial design retains and inherits information from the full factorial such as the standarised orthgonal coding.
To mark that many such attributes are held a special attribute is assigned to the object.

```{r}
# Check to see if the searched attribute exists on the fractional_f4521_64 object.
attributes(fractional_f4521_64)$searched
```

Once an object is search converted it is now easy to run diagonsitcs.

# Step 5: Determining the efficacy of (full or fractional) factorial designs

The theoertical discussion of these diagonstics is presented extensively in the associated note Designing conjoint scaling and discrete choice experiments for small sample expert surveys by Jed Stephens. See Section...

The generalised world length patterns gives a good overall summary of the design.
```{r}
DoE.base::GWLP(fractional_f4521_64)
```

From this we can tell that this fractional factorial design is resolution IV i.e. strength of 3.
Hence the all main effects are estimable free of each other, but some are confounded with two-attribute interactions.

The function `fractional_factorial_efficiency` provides a formula based method of investigating the proposed fractional factorial design in more detials.
This function also includes in its list of results the GWLP so there is no need to specifiy it.

Two examples are given which follow the two examples in the associated note.

```{r}
# Test for main effects
main_effects <- fractional_factorial_efficiency(~ maker + technical + category_rarity + size + age + provenance, fractional_f4521_64)
```

The resultant object has the following objects:

```{r}
names(main_effects)
```

Check the package help file for the `fractional_factorial_efficiency()` function for a full description. 
Also see the associated note for a more technical description.

```{r}
# Test for main effects and interactions described in note.
main_plus_interacts <- fractional_factorial_efficiency(~ maker * technical + category_rarity + size + age * provenance, fractional_f4521_64)
```

This design supports only a single set of two-attribute interactions i.e. maker interact technical, or size interact age or age interact provenance etc. 
However it does not support more than two sets of two-attribute interactions: i.e. in this instance the maker interact technical and age interact provenance.

In instances where some of the stipulated effects cannot be estimated (such as above) then the D-efficiecy would be NaN and similarly the A-efficeny is zero.

# Step 6: Methods to convert from factorial designs to discrete choice experiments

## JS Method
This method is the one proposed in the document Designing conjoint scaling and discrete choice experiments for small sample expert surveys by Jed Stephens.

```{r}
#dce_step <- stephens_pairing(fractional_f4521_64)
dce_modulo <- modulo_method(fractional_f4521_64, 
                            list(c(1,1,1,1,1,1), c(3,3,3,3,3,0)))
```


# Step 7: Efficacy of the Discrete Choice Design

```{r}
#dce_step_efficacy <- dce_effiency(aff4521, dce_step$choice_sets, m = 2)
dce_modulo_efficacy <- dce_effiency(aff4521, dce_modulo, m = 3)
```


# Step 8: Construct a Discrete Choice Question Frame

The function `construct_question_frame` is helpful with the final stages.
It consistently converts a `choice_set` arrangement into a `data.frame`.

```{r}
#question_table_f4521 <- construct_question_frame(aff4521, dce_step$choice_sets, m = 2)
question_table_f4521 <- construct_question_frame(aff4521, dce_modulo_efficacy, m = 3)
```

It is now time to add some useful information back to the levels.
Originally these were described in Step 0, but up until this point it has been nececasury to work with only integer values.
(Also just imagine if you had worked with these very long names up until this point...)

```{r}
levels(question_table_f4521$maker) <- c("little known", "known to specialists", "recognised", "famous")
levels(question_table_f4521$technical) <- c("below average", "good", "meritorious", "exceptional")
levels(question_table_f4521$category_rarity) <- c("common", "uncommon", "rare", "very rare")
levels(question_table_f4521$size) <- c("small: under 150g", "medium: between 151g and 400g", "large: between 401g and 1000g", "extra large: larger than 1000g")
levels(question_table_f4521$age) <- c("21st or 20th Century", "19th Century", "18th Century", "Before 18th Century")
levels(question_table_f4521$provenance) <- c("unavailable or available, but unimportant", "available & important")
View(question_table_f4521)
```

# Replicating the example in Street

The purpose of this section is to replicate the ...
The steps follow those of the tutorial.

```{r}
# Step 0
atttravel  = list(airfaire = c("0", "1"),
                  travel_time =c("0", "1", "2"))
# Step 1
travel2131     <- full_factorial(atttravel)
# Step 2
aff_travel2131 <- augment_levels(travel2131)
# Step 3.
# The full factorial is already so small that selecting a fraction of it would be silly.
# Therefore re-use the full factorial as the fractional fractorial.

# Step 4. 
# Confirming that this is an efficient design.
fractional_travel2131 <- search_design(travel2131, travel2131)

# Step 5.
# Confirm that this design supports all interactions.
full_factorial_efficiacy <- fractional_factorial_efficiency(~ (airfaire + travel_time)^2, fractional_travel2131)

# Step 6 & Step 7.
# Street gives two examples of choice sets.
travel_choice_set1 <- list(c("00", "11", "02"), c("10", "02", "12"))

travel_example <- dce_effiency(aff_travel2131, travel_choice_set1, m = 3)
#Note, if you want to rearrange the columns of the lamda matrix so that they are the same as Street use the following:
# lamda_street_cols  <- matrix(c(travel_example$Lamda$mat[,1],
#                                travel_example$Lamda$mat[,3],
#                                travel_example$Lamda$mat[,5],
#                                travel_example$Lamda$mat[,2],
#                                travel_example$Lamda$mat[,4],
#                                travel_example$Lamda$mat[,6]), ncol = 6)
# lamda_street_paper <- matrix(c(lamda_street_cols[1,],
#                                lamda_street_cols[3,],
#                                lamda_street_cols[5,],
#                                lamda_street_cols[2,],
#                                lamda_street_cols[4,],
#                                lamda_street_cols[6,]), ncol = 6)
# Street gives a second arrangment:
travel_choice_set2 <- list(c("00", "11", "02"), c("10", "01", "12"))
# This version is 100% efficient.
travel_example2 <- dce_effiency(aff_travel2131, travel_choice_set2, m = 3)

# Step 8
travel_questions <- construct_question_frame(aff_travel2131, travel_choice_set2, m = 3, randomise_choice_sets = FALSE)
levels(travel_questions$airfaire) <- c("$350", "$650")
levels(travel_questions$travel_time) <- c("4 hours", "5 hours", "6 hours")
View(travel_questions)
```

